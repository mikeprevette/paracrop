<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ParaCrop</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <style>
        :root { --primary: #007bff; --success: #28a745; --dark: #1a1a1a; --border: #e0e0e0; --bulk: #9f156e77; --link: #42bc20c6; --zip: #fd7e14; --info: #17a2b8; --danger: #ff4444; }
        body { font-family: 'Inter', -apple-system, sans-serif; padding: 20px; background: #f4f7f9; color: #333; margin: 0; min-height: 100vh; }
        
        .container { max-width: 1200px; margin: 20px auto; background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); position: relative; z-index: 1; }
        
        header { 
            margin-bottom: 25px; padding-bottom: 15px; border-bottom: 1px solid var(--border); 
            display: flex; justify-content: space-between; align-items: center; gap: 20px;
        }

        .file-upload-wrapper { position: relative; display: inline-block; }
        #imageInput { position: absolute; left: 0; top: 0; opacity: 0; width: 100%; height: 100%; cursor: pointer; }
        .custom-file-btn {
            display: inline-flex; align-items: center; padding: 12px 24px;
            background: var(--primary); color: white; border-radius: 8px;
            font-weight: 600; cursor: pointer; transition: all 0.2s ease;
            box-shadow: 0 4px 6px rgba(0,123,255,0.2); border: 2px solid transparent;
        }
        .custom-file-btn:hover { background: #0056b3; transform: translateY(-1px); }

        .workspace { display: grid; grid-template-columns: 280px 1fr; gap: 30px; }
        .sidebar { display: flex; flex-direction: column; }
        .group-label { font-weight: 700; color: #999; margin: 15px 0 8px 0; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; }
        .crop-list { display: flex; flex-direction: column; gap: 8px; }
        .crop-btn { display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; cursor: pointer; border: 1px solid var(--border); border-radius: 8px; background: white; font-size: 0.9rem; transition: 0.12s; text-align: left; width: 100%; box-sizing: border-box; }
        .crop-btn.active { background: var(--primary); color: white; border-color: var(--primary); }

        .crop-btn .title { flex: 1; text-align: left; padding-right: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        .preset-controls { display: inline-flex; align-items: center; gap: 8px; }
        .reset-btn, .link-toggle { width: 30px; height: 30px; display: inline-flex; align-items: center; justify-content: center; font-size: 14px; border-radius: 6px; border: 1px solid #e6e6e6; background: #fff; color: #333; cursor: pointer; padding: 0; transition: all 0.12s ease; }
        .reset-btn:hover, .link-toggle:hover { background: #f6f7f8; }
        .link-toggle.active { background: var(--link); color: #fff; border-color: rgba(0,0,0,0.06); box-shadow: 0 6px 18px rgba(111,66,193,0.12); }
        .crop-btn.linked { box-shadow: 0 0 0 2px rgba(111,66,193,0.06) inset; }

        .status-dot { width: 10px; height: 10px; border-radius: 50%; border: 1px solid #ddd; background: transparent; flex-shrink: 0; }
        .is-modified .status-dot { background: var(--success); border-color: var(--success); }
        /* When a preset is both active (selected) and modified, show success color (override white) */
        .crop-btn.active.is-modified .status-dot { background: var(--success); border-color: var(--success); }
        .active .status-dot { border-color: white; background: white; }

        .editor-col { display: flex; flex-direction: column; align-items: flex-start; }
        .img-container { max-height: 70vh; width: 100%; background-color: var(--dark); border-radius: 8px; overflow: hidden; display: none; }
        img { display: block; max-width: 100%; }
        
        #dim-display { 
            margin-bottom: 15px; background: var(--dark); color: #00ff88; 
            padding: 12px 16px; border-radius: 6px; font-family: 'Courier New', monospace; 
            font-size: 0.8rem; line-height: 1.4; width: 100%; box-sizing: border-box; 
            border: 1px solid transparent; transition: all 0.2s;
        }

        #dim-display.warning {
            color: var(--danger);
            border-color: var(--danger);
            background: rgba(255, 68, 68, 0.1);
        }

        .ui-element-box { position: absolute; background: rgba(60, 60, 60, 0.7); border: 1px solid rgba(255, 255, 255, 0.3); pointer-events: none; z-index: 10; }
        .btn-stack { display: flex; flex-direction: column; gap: 10px; margin-top: 25px; }
        .action-btn { width: 100%; padding: 14px; border: none; border-radius: 8px; font-size: 0.95rem; font-weight: bold; cursor: pointer; transition: 0.2s; color: white; }
        .download-btn { background: var(--success); }
        .bulk-btn { background: var(--bulk); }
        .data-btn { background: var(--info); }
        .action-btn:disabled { background: #ccc; cursor: not-allowed; opacity: 0.6; }
        .reset-view-btn { margin-top: 14px; padding: 8px 12px; border-radius: 8px; font-weight: 700; background: #f1f3f5; color: #222; border: 1px solid #e6e6e6; cursor: pointer; }
        .reset-view-btn:hover { background: #eef1f4; }
        .export-config { display: flex; gap: 8px; align-items: center; margin-top: 10px; }
        .export-config label { font-size: 0.7rem; color: #666; margin-right: 6px; }
        .export-config select {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: white;
            /* font-weight: 600; */
            font-family: Inter, -apple-system, system-ui, "Segoe UI", Roboto, "Helvetica Neue", Arial;
            font-size: 0.7rem;
            color: #222;
            box-shadow: 0 2px 6px rgba(0,0,0,0.04);
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            cursor: pointer;
            min-width: 120px;
        }
        /* small caret alignment for selects */
        .export-config select::-ms-expand { display: none; }

        .size-badge { font-size: 0.7rem; color: #666; background: #f6f7f8; padding: 3px 6px; border-radius:6px; border:1px solid #e6e6e6; margin-left:6px; }
        .scale-toggle { width: 30px; height: 30px; display: inline-flex; align-items: center; justify-content: center; font-size: 12px; border-radius: 6px; border: 1px solid #e6e6e6; background: #fff; color: #333; cursor: pointer; padding: 0; }
        .scale-toggle.active { background: #ffd86b; border-color: #ffcc33; color: #222; }

        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(18, 18, 18, 0.98); z-index: 9999; overflow-y: auto; }
        .modal-content { max-width: 1100px; margin: 40px auto; padding: 0 20px; color: white; }
        .modal-header { position: sticky; top: 0; background: #121212; padding: 20px 0; display: flex; justify-content: space-between; align-items: center; z-index: 10; border-bottom: 1px solid #333; gap: 15px; }
        
        .data-table { width: 100%; border-collapse: collapse; margin-top: 30px; background: #222; border-radius: 8px; overflow: hidden; }
        .data-table th, .data-table td { text-align: left; padding: 15px; border-bottom: 1px solid #333; }
        .data-table th { background: #333; color: var(--info); text-transform: uppercase; font-size: 0.75rem; letter-spacing: 1px; }

        .gallery-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 30px; padding: 40px 0; }
        .gallery-item { background: #222; padding: 20px; border-radius: 12px; text-align: center; color: white; border: 1px solid #333; }
        .gallery-item img { max-width: 100%; height: auto; border-radius: 6px; margin-bottom: 15px; border: 1px solid #444; }
        
        #drop-zone-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 123, 255, 0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 10000; color: white; border: 8px dashed white; box-sizing: border-box; }
        /* When crop is too small, make cropper guides/border red */
        .cropper-container.too-small .cropper-view-box,
        .cropper-container.too-small .cropper-face,
        .cropper-container.too-small .cropper-line,
        .cropper-container.too-small .cropper-dashed {
            border-color: var(--danger) !important;
            box-shadow: 0 0 0 2px rgba(255,68,68,0.06) inset !important;
        }
        .cropper-container.too-small .cropper-line { background: var(--danger) !important; }
        /* make the crop handles/points visible in danger color */
        .cropper-container.too-small .cropper-point {
            background: var(--danger) !important;
            border-color: var(--danger) !important;
            box-shadow: none !important;
        }
        .cropper-container.too-small .cropper-point::before,
        .cropper-container.too-small .cropper-point::after {
            background: var(--danger) !important;
        }
    </style>
</head>
<body id="body-drop">

<div id="drop-zone-overlay"><h2>Drop Image</h2></div>

<div class="container">
    <div id="gallery-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin:0; flex-grow: 1;">ParaCrop Export Review</h2>
                <button class="action-btn" style="background: var(--zip); width:auto; padding: 10px 20px;" onclick="downloadAllAsZip()">Download All as ZIP</button>
                <button class="action-btn" style="background: #444; width:auto; padding: 10px 20px;" onclick="closeModal('gallery-overlay')">Back to Editor</button>
            </div>
            <div id="gallery-grid" class="gallery-grid"></div>
        </div>
    </div>

    <div id="data-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Crop Coordinate Manifest</h2>
                <button class="action-btn" style="background: #444; width:auto; padding: 10px 20px;" onclick="closeModal('data-overlay')">Close</button>
            </div>
            <table class="data-table">
                <thead><tr><th>Preset Name</th><th>Top-Left (X, Y)</th><th>Bottom-Right (X, Y)</th><th>Final Size (WxH)</th></tr></thead>
                <tbody id="data-table-body"></tbody>
            </table>
        </div>
    </div>
    
    <header>
        <div class="file-upload-wrapper">
            <label for="imageInput" class="custom-file-btn">Choose or Drop Image</label>
            <input type="file" id="imageInput" accept="image/*">
        </div>
        <h2 style="margin:0;">ParaCrop</h2>
    </header>

    <div class="workspace">
        <div class="sidebar">
            <div id="dynamic-presets"></div>
            <div class="group-label">Tools</div>
            <button class="crop-btn" style="width:100%" onclick="toggleOverlays()"><span id="toggle-text">Hide UI Guides</span></button>

            

            <!-- export panel moved into editor column -->
        </div>

        <div class="editor-col">
            <div id="dim-display">Waiting for image upload...</div>
            <div class="img-container" id="canvas-wrapper"><img id="image"></div>
            <button id="resetViewBtn" class="reset-view-btn" onclick="resetImageView()" disabled style="display:none">Reset Image Position & Zoom</button>
            <!-- editor controls moved here from sidebar -->
            <div style="width:100%; margin-top:18px;">
                <div class="btn-stack" style="flex-direction: row; gap: 10px;">
                    <button class="action-btn download-btn" id="downloadBtn" onclick="performCrop()" disabled style="flex:1;">Download Current</button>
                    <button class="action-btn bulk-btn" id="bulkBtn" onclick="generateGallery()" disabled style="flex:1;">Review All Adjusted</button>
                    <button class="action-btn data-btn" id="dataBtn" onclick="showCoordinateOverlay()" disabled style="flex:1;">View Crop Data Points</button>
                </div>

                <div id="export-controls-wrapper" style="margin-top:12px; display:flex; justify-content:flex-start;">
                    <div class="export-config" id="export-config" style="display:none; flex-direction:row; gap:12px; align-items:center;">
                        <label for="templateSelect" style="font-size:0.8rem; color:#666; margin-right:4px;">Template</label>
                        <select id="templateSelect" style="min-width:120px;">
                            <option value="">â€”</option>
                        </select>

                        <label for="countrySelect" style="font-size:0.8rem; color:#666; margin-left:6px; margin-right:4px;">Country</label>
                        <select id="countrySelect" style="min-width:90px;">
                            <option value="">â€”</option>
                        </select>

                        <div style="display:flex; align-items:center; gap:8px; margin-left:8px;">
                            <label style="font-size:0.8rem; color:#666; margin-left:6px; margin-right:4px;">Example:</label>
                            <div id="exampleFilename" style="font-family: monospace; background:#f6f7f8; color:#222; padding:6px 10px; border-radius:6px; border:1px solid #e6e6e6;">â€”</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let presetConfig = {};

    // Load the presets from an external JSON file (presets.json)
    fetch('presets.json')
        .then(r => {
            if (!r.ok) throw new Error('Network response was not ok');
            return r.json();
        })
        .then(data => {
            presetConfig = data;
            // load persisted state first so UI reflects saved link/reset
            loadStateFromStorage();
            buildPresetsUI();

            // populate export dropdowns from presets.json meta (templates & countries)
            try {
                const meta = presetConfig.__meta__ || presetConfig.meta || {};
                const templates = Array.isArray(meta.templates) ? meta.templates : [];
                const countries = Array.isArray(meta.countries) ? meta.countries : [];
                const tplSelect = document.getElementById('templateSelect');
                if (tplSelect) {
                    tplSelect.innerHTML = '<option value="">â€”</option>';
                    templates.forEach(t => { const o = document.createElement('option'); o.value = t; o.text = t; tplSelect.appendChild(o); });
                }
                const countrySelect = document.getElementById('countrySelect');
                if (countrySelect) {
                    countrySelect.innerHTML = '<option value="">â€”</option>';
                    countries.forEach(c => { const o = document.createElement('option'); o.value = c; o.text = c; countrySelect.appendChild(o); });
                }

                // wire live-updating example filename
                function updateExampleFilename() {
                    const el = document.getElementById('exampleFilename');
                    if (!el) return;
                    // ensure currentId is used for preset portion
                    const name = buildExportFilename(currentId || '');
                    el.textContent = name;
                }

                const tplEl = document.getElementById('templateSelect');
                const countryEl = document.getElementById('countrySelect');
                if (tplEl) tplEl.addEventListener('change', updateExampleFilename);
                if (countryEl) countryEl.addEventListener('change', updateExampleFilename);

                // Expose updater for other parts of the app
                window.updateExampleFilename = updateExampleFilename;

                // initialize the example filename
                setTimeout(() => { try { updateExampleFilename(); } catch (e) {} }, 60);
            } catch (e) { console.warn('Failed to populate export selects from presets.json', e); }

            // reflect persisted modified/linked state in the UI
            Object.keys(cropMemory).forEach(id => {
                const btn = document.querySelector(`.crop-btn[data-id="${id}"]`);
                if (btn) btn.classList.add('is-modified');
            });
            Object.keys(linkedState).forEach(id => {
                if (!linkedState[id]) return;
                const btn = document.querySelector(`.crop-btn[data-id="${id}"]`);
                const linkBtn = btn && btn.querySelector('.link-toggle');
                if (btn) btn.classList.add('linked');
                if (linkBtn) linkBtn.classList.add('active');
                if (cropMemory[id]) {
                    const d = cropMemory[id];
                    lastCenters[id] = { x: d.x + d.width/2, y: d.y + d.height/2 };
                }
            });
        })
        .catch(err => {
            console.error('Failed to load presets.json', err);
            alert('Failed to load presets.json â€” presets unavailable.');
        });

    let cropper, currentId = "default", currentBtn, cropMemory = {}, isSwitching = false, showOverlays = true;
    const imgElement = document.getElementById('image');
    const exportScaleEnabled = {};
    let currentOriginalFilename = '';
    let currentOriginalBasename = '';

    // Link state for presets: when true the preset is part of the moving-center group
    const linkedState = {};
    const lastCenters = {};
    const adjustedState = {};

    // Persisted state keys
    const STORAGE_KEY = 'paracrop_state_v1';

    // Clear persisted crop settings when the page is reloaded (prevents carrying settings across refresh)
    try {
        const navEntries = performance.getEntriesByType ? performance.getEntriesByType('navigation') : [];
        const nav = (navEntries && navEntries.length) ? navEntries[0] : (performance.navigation || null);
        const isReload = nav && ((nav.type && nav.type === 'reload') || (nav.type === 1));
        if (isReload) {
            try { localStorage.removeItem(STORAGE_KEY); } catch (e) {}
            console.info('Paracrop: cleared persisted crop settings due to page reload');
        }
    } catch (e) { /* ignore */ }

    function saveStateToStorage() {
        try {
            const payload = { linkedState, cropMemory, adjustedState, exportScaleEnabled };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        } catch (e) {
            console.warn('Failed to save Paracrop state', e);
        }
    }

    function loadStateFromStorage() {
        try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return;
            const parsed = JSON.parse(raw);
            if (parsed.linkedState) Object.assign(linkedState, parsed.linkedState);
            if (parsed.cropMemory) Object.assign(cropMemory, parsed.cropMemory);
            if (parsed.adjustedState) Object.assign(adjustedState, parsed.adjustedState);
            if (parsed.exportScaleEnabled) Object.assign(exportScaleEnabled, parsed.exportScaleEnabled);
        } catch (e) {
            console.warn('Failed to load Paracrop state', e);
        }
    }

    // UI Initializer - renders presets and a link-toggle control per preset
    function buildPresetsUI() {
        const container = document.getElementById('dynamic-presets');
        container.innerHTML = '';
        const groups = {};
        
        Object.entries(presetConfig).forEach(([id, cfg]) => {
            // skip meta entries or invalid preset entries
            if (!id || id.startsWith('__')) return;
            if (!cfg || typeof cfg !== 'object' || !cfg.group) return;
            if (!groups[cfg.group]) groups[cfg.group] = [];
            groups[cfg.group].push({ id, ...cfg });
        });

        Object.keys(groups).forEach(groupName => {
            const label = document.createElement('div');
            label.className = 'group-label';
            label.innerText = groupName;
            container.appendChild(label);

            const list = document.createElement('div');
            list.className = 'crop-list';
            
            groups[groupName].forEach(cfg => {
                const btn = document.createElement('button');
                btn.className = `crop-btn ${cfg.id === currentId ? 'active' : ''}`;
                btn.setAttribute('data-id', cfg.id);

                const leftSpan = document.createElement('span');
                leftSpan.className = 'title';
                leftSpan.innerText = cfg.title;

                const rightControls = document.createElement('span');
                rightControls.className = 'preset-controls';

                const resetBtn = document.createElement('button');
                resetBtn.type = 'button';
                resetBtn.className = 'reset-btn';
                resetBtn.title = 'Reset this preset crop';
                resetBtn.innerText = 'â†º';

                const linkBtn = document.createElement('button');
                linkBtn.type = 'button';
                linkBtn.className = 'link-toggle';
                linkBtn.title = 'Link center for group move';
                linkBtn.innerText = 'ðŸ”—';

                // Export scale toggle (per-preset)
                const scaleBtn = document.createElement('button');
                scaleBtn.type = 'button';
                scaleBtn.className = 'link-toggle scale-toggle';
                scaleBtn.title = 'Toggle scaled export for this preset';
                scaleBtn.innerText = 'S';

                // If preset has exportSize, show a small badge of target size
                const sizeBadge = document.createElement('span');
                sizeBadge.className = 'size-badge';
                if (cfg.exportSize && cfg.exportSize.width && cfg.exportSize.height) {
                    sizeBadge.innerText = `${cfg.exportSize.width}x${cfg.exportSize.height}`;
                } else {
                    sizeBadge.style.display = 'none';
                }

                const statusDot = document.createElement('span');
                statusDot.className = 'status-dot';

                // Clicking the preset selects it
                btn.addEventListener('click', () => {
                    handlePresetChange(cfg.ratio, btn);
                });

                // Reset without selecting the preset
                resetBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    resetPresetCrop(cfg.id, resetBtn, btn);
                });

                // Toggle linking without selecting the preset
                linkBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleLink(cfg.id, linkBtn, btn);
                });

                rightControls.appendChild(resetBtn);
                rightControls.appendChild(linkBtn);
                rightControls.appendChild(scaleBtn);
                rightControls.appendChild(statusDot);
                rightControls.appendChild(sizeBadge);

                btn.appendChild(leftSpan);
                btn.appendChild(rightControls);

                // reflect persisted states
                if (linkedState[cfg.id]) {
                    linkBtn.classList.add('active');
                    btn.classList.add('linked');
                    if (cropMemory[cfg.id]) {
                        const d = cropMemory[cfg.id];
                        lastCenters[cfg.id] = { x: d.x + d.width/2, y: d.y + d.height/2 };
                    }
                }
                if (adjustedState[cfg.id]) {
                    btn.classList.add('is-modified');
                }
                // export scale persisted or default
                const scaleDefault = (cfg.exportSize && cfg.exportSize.width && cfg.exportSize.height) ? true : false;
                const enabled = (exportScaleEnabled.hasOwnProperty(cfg.id)) ? !!exportScaleEnabled[cfg.id] : scaleDefault;
                scaleBtn.classList.toggle('active', enabled);
                if (enabled) exportScaleEnabled[cfg.id] = true;

                // Wire scale toggle click
                scaleBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const cur = !!exportScaleEnabled[cfg.id];
                    exportScaleEnabled[cfg.id] = !cur;
                    scaleBtn.classList.toggle('active', !cur);
                    saveStateToStorage();
                });

                list.appendChild(btn);
                if (cfg.id === currentId) currentBtn = btn;
            });
            container.appendChild(list);
        });
    }
    

    function processFile(file) {
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            imgElement.src = e.target.result;
            document.getElementById('canvas-wrapper').style.display = 'block';
            if (cropper) cropper.destroy();
            cropMemory = {};
            // clear adjusted flags and last centers so previous image adjustments do not carry over
            Object.keys(adjustedState).forEach(k => delete adjustedState[k]);
            Object.keys(lastCenters).forEach(k => delete lastCenters[k]);
            document.querySelectorAll('.crop-btn').forEach(b => b.classList.remove('is-modified'));
            // persist cleared adjustedState
            saveStateToStorage();
            ['downloadBtn', 'bulkBtn', 'dataBtn', 'resetViewBtn'].forEach(id => document.getElementById(id).disabled = false);
            // show the reset view button once an image has been loaded
            const rv = document.getElementById('resetViewBtn'); if (rv) rv.style.display = 'inline-block';
            // show export config controls
            const ec = document.getElementById('export-config'); if (ec) ec.style.display = 'flex';

            // store original file name info for exports
            try {
                currentOriginalFilename = file.name || '';
                // remove extension for basename
                const idx = currentOriginalFilename.lastIndexOf('.');
                currentOriginalBasename = idx > 0 ? currentOriginalFilename.substring(0, idx) : currentOriginalFilename;
            } catch (e) { currentOriginalFilename = currentOriginalBasename = ''; }

            initCropper();
        };
        reader.readAsDataURL(file);
    }

    function initCropper() {
        cropper = new Cropper(imgElement, {
            viewMode: 1,
            aspectRatio: (function(){ const r = presetConfig[currentId]?.ratio; return (typeof r === 'number' && isFinite(r)) ? r : NaN; })(),
            autoCropArea: 0.8,
            crop(event) {
                if (isSwitching) return;
                const d = cropper.getData(true);
                const min = presetConfig[currentId].minSize || 500;
                const isTooSmall = Math.min(d.width, d.height) < min;
                
                const display = document.getElementById('dim-display');
                display.className = isTooSmall ? 'warning' : '';
                
                // Displaying TL and BR coordinates (include preset minimum when too small)
                const minText = isTooSmall ? ` <b>(TOO SMALL â€” min ${min}px)</b>` : '';
                display.innerHTML = `Size: ${Math.round(d.width)}x${Math.round(d.height)}px | TL: ${Math.round(d.x)},${Math.round(d.y)} | BR: ${Math.round(d.x+d.width)},${Math.round(d.y+d.height)}${minText}`;
                
                // compute new center
                const newCenter = { x: d.x + d.width/2, y: d.y + d.height/2 };

                // determine if this is the first adjustment for this preset
                const firstAdjust = !cropMemory[currentId];

                // store the data for this preset
                cropMemory[currentId] = { ...d };
                if (currentBtn) {
                    currentBtn.classList.add('is-modified');
                }

                // mark as adjusted (this distinguishes a reposition from default/cleared state)
                adjustedState[currentId] = true;
                saveStateToStorage();

                // If this preset had a previous center, apply delta to linked presets
                const prev = lastCenters[currentId];
                if (prev) {
                    const dx = newCenter.x - prev.x;
                    const dy = newCenter.y - prev.y;
                    if ((dx !== 0 || dy !== 0) && Object.values(linkedState).some(v => v)) {
                        applyCenterDeltaToLinked(dx, dy, currentId);
                    }
                }

                // update last center for this preset
                lastCenters[currentId] = newCenter;

                // toggle visual state on the cropper container so guide lines/borders can change color
                try {
                    const container = document.querySelector('.cropper-container');
                    if (container) container.classList.toggle('too-small', isTooSmall);
                } catch (e) { /* ignore */ }

                // persist crop changes
                saveStateToStorage();
            },
            ready: updateUIOverlay
        });
    }

    function handlePresetChange(ratio, btn) {
        if (!cropper) return;
        isSwitching = true;
        document.querySelectorAll('.crop-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentBtn = btn;
        currentId = btn.getAttribute('data-id');
        const effectiveRatio = (typeof ratio === 'number' && isFinite(ratio)) ? ratio : NaN;
        cropper.setAspectRatio(effectiveRatio);
        if (cropMemory[currentId]) {
            cropper.setData(cropMemory[currentId]);
            // initialize last center for newly-selected preset
            const d = cropMemory[currentId];
            lastCenters[currentId] = { x: d.x + d.width/2, y: d.y + d.height/2 };
        }
        // clear any previous too-small highlight when switching presets
        try { const container = document.querySelector('.cropper-container'); if (container) container.classList.remove('too-small'); } catch(e){}

        updateUIOverlay();
        try { if (typeof window.updateExampleFilename === 'function') window.updateExampleFilename(); } catch(e){}
        setTimeout(() => { isSwitching = false; }, 150);
    }

    function updateUIOverlay() {
        const viewBox = document.querySelector('.cropper-view-box');
        if (!viewBox) return;
        viewBox.querySelectorAll('.ui-element-box').forEach(el => el.remove());
        if (!showOverlays) return;
        
        const overlays = presetConfig[currentId]?.overlays || [];
        overlays.forEach(o => {
            const div = document.createElement('div');
            div.className = 'ui-element-box';
            Object.assign(div.style, { 
                top: o.top + '%', 
                left: o.left + '%', 
                width: o.width + '%', 
                height: o.height + '%' 
            });
            viewBox.appendChild(div);
        });
    }

    // Toggle link state for a preset
    function toggleLink(id, linkBtn, parentBtn) {
        linkedState[id] = !linkedState[id];
        linkBtn.classList.toggle('active', linkedState[id]);
        parentBtn.classList.toggle('linked', linkedState[id]);

        // initialize last center if this preset already has crop data
        if (linkedState[id] && cropMemory[id]) {
            const d = cropMemory[id];
            lastCenters[id] = { x: d.x + d.width/2, y: d.y + d.height/2 };
        } else {
            delete lastCenters[id];
        }
        saveStateToStorage();
    }

    // Reset a preset's stored crop data and (if active) reset the cropper view
    function resetPresetCrop(id, resetBtn, parentBtn) {
        delete cropMemory[id];
        delete lastCenters[id];
        parentBtn.classList.remove('is-modified');

        // persist removal
        // clear adjusted state
        delete adjustedState[id];
        saveStateToStorage();

        // If the preset is currently selected, reset the cropper view to initial state
        if (id === currentId && cropper) {
            isSwitching = true;
            try {
                cropper.reset();
            } catch (e) {
                try { cropper.destroy(); } catch (err) {}
                initCropper();
            }
            const r = presetConfig[currentId]?.ratio;
            try { cropper.setAspectRatio((typeof r === 'number' && isFinite(r)) ? r : NaN); } catch (e) {}
            updateUIOverlay();
            try { const container = document.querySelector('.cropper-container'); if (container) container.classList.remove('too-small'); } catch(e){}
            setTimeout(() => { isSwitching = false; }, 120);
        } else {
            updateUIOverlay();
        }
    }

    // Reset image position & zoom (preserves crop data if present)
    function resetImageView() {
        if (!cropper) return;
        isSwitching = true;
        try {
            cropper.reset();
        } catch (e) {
            try { cropper.destroy(); } catch (err) {}
            initCropper();
        }

        // remove too-small visual state after resetting
        try { const container = document.querySelector('.cropper-container'); if (container) container.classList.remove('too-small'); } catch(e){}

        // if there's stored crop data for the current preset, reapply it
        if (cropMemory[currentId]) {
            try { cropper.setData(cropMemory[currentId]); } catch (e) {}
        }

        updateUIOverlay();
        setTimeout(() => { isSwitching = false; }, 120);
    }

    // Apply a center delta to all linked presets (does not change the active cropper view)
    function applyCenterDeltaToLinked(dx, dy, sourceId) {
        const imgW = imgElement.naturalWidth || imgElement.width || 1;
        const imgH = imgElement.naturalHeight || imgElement.height || 1;

        Object.keys(linkedState).forEach(id => {
            if (!linkedState[id] || id === sourceId) return;
            let d = cropMemory[id];
            if (!d) {
                // create a default based on source dimensions and target ratio
                const src = cropMemory[sourceId];
                if (!src) return;
                let w = src.width;
                let h = src.height;
                const r = presetConfig[id]?.ratio;
                if (typeof r === 'number' && isFinite(r) && r > 0) {
                    h = Math.round(w / r);
                }
                w = Math.min(w, imgW);
                h = Math.min(h, imgH);
                d = { width: w, height: h, x: Math.max(0, Math.min(src.x, imgW - w)), y: Math.max(0, Math.min(src.y, imgH - h)) };
            }

            const cx = d.x + d.width/2 + dx;
            const cy = d.y + d.height/2 + dy;
            let newX = cx - d.width/2;
            let newY = cy - d.height/2;
            newX = Math.max(0, Math.min(newX, imgW - d.width));
            newY = Math.max(0, Math.min(newY, imgH - d.height));

            cropMemory[id] = { ...d, x: newX, y: newY };
            const btn = document.querySelector(`.crop-btn[data-id="${id}"]`);
            if (btn) btn.classList.add('is-modified');
            lastCenters[id] = { x: newX + d.width/2, y: newY + d.height/2 };
            // linked move counts as an adjustment
            adjustedState[id] = true;
        });
        // persist linked crop changes all at once
        saveStateToStorage();
    }

    // Helper: Returns a Canvas based on stored crop data
    function getCroppedCanvas(data) {
        const canvas = document.createElement('canvas');
        canvas.width = data.width;
        canvas.height = data.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(imgElement, data.x, data.y, data.width, data.height, 0, 0, data.width, data.height);
        return canvas;
    }

    /**
     * Returns a canvas for the cropped data scaled to the preset's exportSize when available.
     * - If the preset has no exportSize, returns the original cropped canvas.
     * - Honors `allowUpscale` (if false, will not enlarge beyond the source crop size).
     */
    function getCroppedCanvasScaled(data, presetId) {
        const srcCanvas = getCroppedCanvas(data);
        try {
            // honor per-preset toggle: if user has disabled scaled export for this preset, return source canvas
            if (exportScaleEnabled.hasOwnProperty(presetId) && !exportScaleEnabled[presetId]) return srcCanvas;
            const preset = presetConfig[presetId] || {};
            const exp = preset.exportSize;
            if (!exp || !exp.width || !exp.height) return srcCanvas;

            let targetW = Number(exp.width) || srcCanvas.width;
            let targetH = Number(exp.height) || srcCanvas.height;

            // If upscaling is not allowed, clamp the target size down proportionally
            const allowUpscale = !!exp.allowUpscale;
            if (!allowUpscale) {
                const scale = Math.min(1, srcCanvas.width / targetW, srcCanvas.height / targetH);
                targetW = Math.max(1, Math.round(targetW * scale));
                targetH = Math.max(1, Math.round(targetH * scale));
            }

            // If target matches source, return source to avoid extra work
            if (targetW === srcCanvas.width && targetH === srcCanvas.height) return srcCanvas;

            const out = document.createElement('canvas');
            out.width = targetW;
            out.height = targetH;
            const ctx = out.getContext('2d');
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(srcCanvas, 0, 0, srcCanvas.width, srcCanvas.height, 0, 0, targetW, targetH);
            return out;
        } catch (e) {
            console.warn('getCroppedCanvasScaled failed, falling back to unscaled canvas', e);
            return srcCanvas;
        }
    }

    function performCrop() {
        if (!cropper || !cropMemory[currentId]) return;
        const filename = buildExportFilename(currentId);
        const canvas = getCroppedCanvasScaled(cropMemory[currentId], currentId);
        canvas.toBlob(blob => {
            saveAs(blob, filename);
        }, 'image/jpeg', 0.95);
    }

    function generateGallery() {
        try {
            const grid = document.getElementById('gallery-grid');
            if (!grid) throw new Error('Gallery grid element not found');
            grid.innerHTML = '';

            // Prefer adjustedState to determine which presets the user has modified
            const modifiedIds = Object.keys(adjustedState).filter(id => adjustedState[id]);

            if (!modifiedIds || modifiedIds.length === 0) {
                alert("Please adjust at least one crop first.");
                return;
            }

            let anyAdded = false;
            modifiedIds.forEach(id => {
                try {
                    const data = cropMemory[id];
                    if (!data) return; // skip entries without stored crop data
                    const canvas = getCroppedCanvasScaled(data, id);
                    const item = document.createElement('div');
                    item.className = 'gallery-item';
                    const filename = buildExportFilename(id);

                    item.innerHTML = `
                        <img src="${canvas.toDataURL('image/jpeg', 0.5)}">
                        <span style="display:block; margin-bottom:6px; font-weight:bold;">${presetConfig[id]?.title || id}</span>
                        <div style="font-family: monospace; font-size:0.85rem; color:#ddd; margin-bottom:8px; word-break:break-all;">${filename}</div>
                        <button class="action-btn download-btn" onclick="downloadSingleFromGallery('${id}')">Download JPG</button>
                    `;
                    grid.appendChild(item);
                    anyAdded = true;
                } catch (innerErr) {
                    console.warn('Skipping gallery item for', id, innerErr);
                }
            });

            if (!anyAdded) {
                alert('No valid adjusted crops available to preview.');
                return;
            }

            const overlay = document.getElementById('gallery-overlay');
            if (!overlay) throw new Error('Gallery overlay element not found');
            overlay.style.display = 'block';
        } catch (err) {
            console.error('generateGallery failed', err);
            alert('Failed to open gallery â€” see console for details.');
        }
    }

    window.downloadSingleFromGallery = (id) => {
        const filename = buildExportFilename(id);
        const canvas = getCroppedCanvasScaled(cropMemory[id], id);
        canvas.toBlob(blob => saveAs(blob, filename), 'image/jpeg', 0.95);
    };

    async function downloadAllAsZip() {
        const zip = new JSZip();
        const modifiedIds = Object.keys(cropMemory);

        for (const id of modifiedIds) {
            const canvas = getCroppedCanvasScaled(cropMemory[id], id);
            const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.95));
            const filename = buildExportFilename(id);
            zip.file(filename, blob);
        }
        
        const content = await zip.generateAsync({type:"blob"});
        // Build zip filename as <originalBase>_imageset_MMDDYYYY.zip
        const now = new Date();
        const mm = String(now.getMonth() + 1).padStart(2, '0');
        const dd = String(now.getDate()).padStart(2, '0');
        const yyyy = String(now.getFullYear());
        const dateToken = `${mm}${dd}${yyyy}`;
        const base = sanitizeToken(currentOriginalBasename) || 'image';
        const zipName = `${base}_imageset_${dateToken}.zip`;
        saveAs(content, zipName);
    }

    // Helper: sanitize token for filename components
    function sanitizeToken(s) {
        if (!s) return '';
        return String(s).trim().replace(/\s+/g, '-').replace(/[^A-Za-z0-9\-_]/g, '');
    }

    // Build export filename for a given preset id using selected Template, Country, Year, preset prefix, and original filename base
    function buildExportFilename(presetId) {
        const tpl = document.getElementById('templateSelect')?.value || '';
        const country = document.getElementById('countrySelect')?.value || '';
        const year = (new Date()).getFullYear();
        const presetPrefix = presetConfig[presetId]?.prefix || presetId;
        const parts = [];
        if (tpl) parts.push(sanitizeToken(tpl));
        if (country) parts.push(sanitizeToken(country));
        parts.push(String(year));
        parts.push(sanitizeToken(presetPrefix));
        const base = sanitizeToken(currentOriginalBasename) || 'image';
        parts.push(base);
        // join with underscore and ensure .jpg extension
        return parts.join('_') + '.jpg';
    }

    function showCoordinateOverlay() {
        const body = document.getElementById('data-table-body');
        // show rows only for presets that have crop data
        const rows = Object.entries(cropMemory).map(([id, d]) => `
            <tr>
                <td><b>${presetConfig[id]?.title || id}</b></td>
                <td>${Math.round(d.x)}, ${Math.round(d.y)}</td>
                <td>${Math.round(d.x + d.width)}, ${Math.round(d.y + d.height)}</td>
                <td>${Math.round(d.width)} x ${Math.round(d.height)}px</td>
            </tr>`).join('');
        if (!rows) {
            alert('No crop data available to show.');
            return;
        }
        body.innerHTML = rows;
        document.getElementById('data-overlay').style.display = 'block';
    }

    function toggleOverlays() {
        showOverlays = !showOverlays;
        document.getElementById('toggle-text').innerText = showOverlays ? "Hide UI Guides" : "Show UI Guides";
        updateUIOverlay();
    }

    function closeModal(id) { document.getElementById(id).style.display = 'none'; }

    // Drop Zone & Input Listeners
    document.getElementById('imageInput').addEventListener('change', (e) => processFile(e.target.files[0]));
    
    window.addEventListener('dragover', (e) => { 
        e.preventDefault(); 
        document.getElementById('drop-zone-overlay').style.display = 'flex'; 
    });
    
    document.getElementById('drop-zone-overlay').addEventListener('dragleave', () => {
        document.getElementById('drop-zone-overlay').style.display = 'none';
    });
    
    window.addEventListener('drop', (e) => { 
        e.preventDefault(); 
        document.getElementById('drop-zone-overlay').style.display = 'none'; 
        processFile(e.dataTransfer.files[0]); 
    });
</script>
</body>
</html>