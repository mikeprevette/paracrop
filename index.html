<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ParaCrop</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <link href="styles.css" rel="stylesheet">
</head>
<body id="body-drop">

<div id="drop-zone-overlay"><h2>Drop Image</h2></div>

<div class="container">
    <div id="gallery-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin:0; flex-grow: 1;">ParaCrop Export Review</h2>
                <button class="action-btn" style="background: var(--zip); width:auto; padding: 10px 20px;" onclick="downloadAllAsZip()">Download All as ZIP</button>
                <button class="action-btn" style="background: #444; width:auto; padding: 10px 20px;" onclick="closeModal('gallery-overlay')">Back to Editor</button>
            </div>
            <div id="gallery-grid" class="gallery-grid"></div>
        </div>
    </div>

    <div id="data-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Crop Coordinate Manifest</h2>
                <button class="action-btn" style="background: #444; width:auto; padding: 10px 20px;" onclick="closeModal('data-overlay')">Close</button>
            </div>
            <table class="data-table">
                <thead><tr><th>Preset Name</th><th>Top-Left (X, Y)</th><th>Bottom-Right (X, Y)</th><th>Final Size (WxH)</th></tr></thead>
                <tbody id="data-table-body"></tbody>
            </table>
        </div>
    </div>
    
    <header>
        <div class="file-upload-wrapper">
            <label for="imageInput" class="custom-file-btn">Choose or Drop Image</label>
            <input type="file" id="imageInput" accept="image/*">
        </div>
        <h2 style="margin:0;">ParaCrop</h2>
    </header>

    <div class="workspace">
        <div class="sidebar">
            <div id="dynamic-presets"></div>
            <div class="group-label">Tools</div>
            <button class="crop-btn" style="width:100%" onclick="toggleOverlays()"><span id="toggle-text">Hide UI Guides</span></button>

            

            <!-- export panel moved into editor column -->
        </div>

        <div class="editor-col">
            <div id="dim-display">Waiting for image upload...</div>
            <div class="img-container" id="canvas-wrapper"><img id="image"></div>
            <button id="resetViewBtn" class="reset-view-btn" onclick="resetImageView()" disabled style="display:none">Reset Image Position & Zoom</button>
            <!-- editor controls moved here from sidebar -->
            <div style="width:100%; margin-top:18px;">
                <div class="btn-stack" style="flex-direction: row; gap: 10px;">
                    <button class="action-btn download-btn" id="downloadBtn" onclick="performCrop()" disabled style="flex:1;">Download Current</button>
                    <button class="action-btn bulk-btn" id="bulkBtn" onclick="generateGallery()" disabled style="flex:1;">Review All Adjusted</button>
                    <button class="action-btn data-btn" id="dataBtn" onclick="showCoordinateOverlay()" disabled style="flex:1;">View Crop Data Points</button>
                </div>

                <div id="export-controls-wrapper" style="margin-top:12px; display:flex; justify-content:flex-start;">
                    <div class="export-config" id="export-config" style="display:none; flex-direction:row; gap:12px; align-items:center;">
                        <label for="templateSelect" style="font-size:0.8rem; color:#666; margin-right:4px;">Template</label>
                        <select id="templateSelect" style="min-width:120px;">
                            <option value="">â€”</option>
                        </select>

                        <label for="countrySelect" style="font-size:0.8rem; color:#666; margin-left:6px; margin-right:4px;">Country</label>
                        <select id="countrySelect" style="min-width:90px;">
                            <option value="">â€”</option>
                        </select>

                        <div style="display:flex; align-items:center; gap:8px; margin-left:8px;">
                            <label style="font-size:0.8rem; color:#666; margin-left:6px; margin-right:4px;">Example:</label>
                            <div id="exampleFilename" style="font-family: monospace; background:#f6f7f8; color:#222; padding:6px 10px; border-radius:6px; border:1px solid #e6e6e6;">â€”</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let presetConfig = {};

    // Load the presets from an external JSON file (presets.json)
    fetch('presets.json')
        .then(r => {
            if (!r.ok) throw new Error('Network response was not ok');
            return r.json();
        })
        .then(data => {
            presetConfig = data;
            // load persisted state first so UI reflects saved link/reset
            loadStateFromStorage();
            buildPresetsUI();

            // populate export dropdowns from presets.json meta (templates & countries)
            try {
                const meta = presetConfig.__meta__ || presetConfig.meta || {};
                const templates = Array.isArray(meta.templates) ? meta.templates : [];
                const countries = Array.isArray(meta.countries) ? meta.countries : [];
                const tplSelect = document.getElementById('templateSelect');
                if (tplSelect) {
                    tplSelect.innerHTML = '<option value="">â€”</option>';
                    templates.forEach(t => { const o = document.createElement('option'); o.value = t; o.text = t; tplSelect.appendChild(o); });
                }
                const countrySelect = document.getElementById('countrySelect');
                if (countrySelect) {
                    countrySelect.innerHTML = '<option value="">â€”</option>';
                    countries.forEach(c => { const o = document.createElement('option'); o.value = c; o.text = c; countrySelect.appendChild(o); });
                }

                // wire live-updating example filename
                function updateExampleFilename() {
                    const el = document.getElementById('exampleFilename');
                    if (!el) return;
                    // ensure currentId is used for preset portion
                    const name = buildExportFilename(currentId || '');
                    el.textContent = name;
                }

                const tplEl = document.getElementById('templateSelect');
                const countryEl = document.getElementById('countrySelect');
                if (tplEl) tplEl.addEventListener('change', updateExampleFilename);
                if (countryEl) countryEl.addEventListener('change', updateExampleFilename);

                // Expose updater for other parts of the app
                window.updateExampleFilename = updateExampleFilename;

                // initialize the example filename
                setTimeout(() => { try { updateExampleFilename(); } catch (e) {} }, 60);
            } catch (e) { console.warn('Failed to populate export selects from presets.json', e); }

            // reflect persisted modified/linked state in the UI
            Object.keys(cropMemory).forEach(id => {
                const btn = document.querySelector(`.crop-btn[data-id="${id}"]`);
                if (btn) btn.classList.add('is-modified');
            });
            Object.keys(linkedState).forEach(id => {
                if (!linkedState[id]) return;
                const btn = document.querySelector(`.crop-btn[data-id="${id}"]`);
                const linkBtn = btn && btn.querySelector('.link-toggle');
                if (btn) btn.classList.add('linked');
                if (linkBtn) linkBtn.classList.add('active');
                if (cropMemory[id]) {
                    const d = cropMemory[id];
                    lastCenters[id] = { x: d.x + d.width/2, y: d.y + d.height/2 };
                }
            });
        })
        .catch(err => {
            console.error('Failed to load presets.json', err);
            alert('Failed to load presets.json â€” presets unavailable.');
        });

    let cropper, currentId = "default", currentBtn, cropMemory = {}, isSwitching = false, showOverlays = true;
    const sizeBadges = {}; // map presetId -> sizeBadge element
    const imgElement = document.getElementById('image');
    const exportScaleEnabled = {};
    let currentOriginalFilename = '';
    let currentOriginalBasename = '';

    // Link state for presets: when true the preset is part of the moving-center group
    const linkedState = {};
    const lastCenters = {};
    const adjustedState = {};

    // Persisted state keys
    const STORAGE_KEY = 'paracrop_state_v1';

    // Clear persisted crop settings when the page is reloaded (prevents carrying settings across refresh)
    try {
        const navEntries = performance.getEntriesByType ? performance.getEntriesByType('navigation') : [];
        const nav = (navEntries && navEntries.length) ? navEntries[0] : (performance.navigation || null);
        const isReload = nav && ((nav.type && nav.type === 'reload') || (nav.type === 1));
        if (isReload) {
            try { localStorage.removeItem(STORAGE_KEY); } catch (e) {}
            console.info('Paracrop: cleared persisted crop settings due to page reload');
        }
    } catch (e) { /* ignore */ }

    function saveStateToStorage() {
        try {
            const payload = { linkedState, cropMemory, adjustedState, exportScaleEnabled };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        } catch (e) {
            console.warn('Failed to save Paracrop state', e);
        }
    }

    function loadStateFromStorage() {
        try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return;
            const parsed = JSON.parse(raw);
            if (parsed.linkedState) Object.assign(linkedState, parsed.linkedState);
            if (parsed.cropMemory) Object.assign(cropMemory, parsed.cropMemory);
            if (parsed.adjustedState) Object.assign(adjustedState, parsed.adjustedState);
            if (parsed.exportScaleEnabled) Object.assign(exportScaleEnabled, parsed.exportScaleEnabled);
        } catch (e) {
            console.warn('Failed to load Paracrop state', e);
        }
    }

    // UI Initializer - renders presets and a link-toggle control per preset
    function buildPresetsUI() {
        const container = document.getElementById('dynamic-presets');
        container.innerHTML = '';
        const groups = {};
        
        Object.entries(presetConfig).forEach(([id, cfg]) => {
            // skip meta entries or invalid preset entries
            if (!id || id.startsWith('__')) return;
            if (!cfg || typeof cfg !== 'object' || !cfg.group) return;
            if (!groups[cfg.group]) groups[cfg.group] = [];
            groups[cfg.group].push({ id, ...cfg });
        });

        Object.keys(groups).forEach(groupName => {
            const label = document.createElement('div');
            label.className = 'group-label';
            label.innerText = groupName;
            container.appendChild(label);

            const list = document.createElement('div');
            list.className = 'crop-list';
            
            groups[groupName].forEach(cfg => {
                const btn = document.createElement('button');
                btn.className = `crop-btn ${cfg.id === currentId ? 'active' : ''}`;
                btn.setAttribute('data-id', cfg.id);

                const leftSpan = document.createElement('span');
                leftSpan.className = 'title';
                leftSpan.innerText = cfg.title;

                const rightControls = document.createElement('span');
                rightControls.className = 'preset-controls';

                const resetBtn = document.createElement('button');
                resetBtn.type = 'button';
                resetBtn.className = 'reset-btn';
                resetBtn.title = 'Reset this preset crop';
                resetBtn.innerText = 'â†º';

                const linkBtn = document.createElement('button');
                linkBtn.type = 'button';
                linkBtn.className = 'link-toggle';
                linkBtn.title = 'Link center for group move';
                linkBtn.innerText = 'ðŸ”—';

                // Note: export scaling is toggled by clicking the size badge (see below)

                // If preset has exportSize, show a small badge of target size
                const sizeBadge = document.createElement('span');
                sizeBadge.className = 'size-badge';
                if (cfg.exportSize && cfg.exportSize.width && cfg.exportSize.height) {
                    sizeBadge.innerText = `${cfg.exportSize.width}x${cfg.exportSize.height}`;
                } else {
                    sizeBadge.style.display = 'none';
                }
                // register badge for runtime updates
                sizeBadges[cfg.id] = sizeBadge;

                const statusDot = document.createElement('span');
                statusDot.className = 'status-dot';

                // Clicking the preset selects it
                btn.addEventListener('click', () => {
                    handlePresetChange(cfg.ratio, btn);
                });

                // Reset without selecting the preset
                resetBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    resetPresetCrop(cfg.id, resetBtn, btn);
                });

                // Toggle linking without selecting the preset
                linkBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleLink(cfg.id, linkBtn, btn);
                });

                rightControls.appendChild(resetBtn);
                rightControls.appendChild(linkBtn);

                const topLine = document.createElement('div');
                topLine.className = 'preset-top';
                topLine.appendChild(leftSpan);
                topLine.appendChild(statusDot);

                const bottomLine = document.createElement('div');
                bottomLine.className = 'preset-bottom';
                bottomLine.appendChild(rightControls);
                bottomLine.appendChild(sizeBadge);

                btn.appendChild(topLine);
                btn.appendChild(bottomLine);

                // reflect persisted states
                if (linkedState[cfg.id]) {
                    linkBtn.classList.add('active');
                    btn.classList.add('linked');
                    if (cropMemory[cfg.id]) {
                        const d = cropMemory[cfg.id];
                        lastCenters[cfg.id] = { x: d.x + d.width/2, y: d.y + d.height/2 };
                    }
                }
                if (adjustedState[cfg.id]) {
                    btn.classList.add('is-modified');
                }
                // export scale persisted or default â€” show via size badge
                const scaleDefault = (cfg.exportSize && cfg.exportSize.width && cfg.exportSize.height) ? true : false;
                const enabled = (exportScaleEnabled.hasOwnProperty(cfg.id)) ? !!exportScaleEnabled[cfg.id] : scaleDefault;
                sizeBadge.classList.toggle('active', enabled);
                if (enabled) exportScaleEnabled[cfg.id] = true;

                // Wire size badge click to toggle scaling (stop propagation so it doesn't select the preset)
                sizeBadge.style.cursor = 'pointer';
                sizeBadge.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const cur = !!exportScaleEnabled[cfg.id];
                    exportScaleEnabled[cfg.id] = !cur;
                    sizeBadge.classList.toggle('active', !cur);
                    saveStateToStorage();
                });

                list.appendChild(btn);
                if (cfg.id === currentId) currentBtn = btn;
            });
            container.appendChild(list);
        });
    }
    

    function processFile(file) {
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            imgElement.src = e.target.result;
            document.getElementById('canvas-wrapper').style.display = 'block';
            if (cropper) cropper.destroy();
            cropMemory = {};
            // clear adjusted flags and last centers so previous image adjustments do not carry over
            Object.keys(adjustedState).forEach(k => delete adjustedState[k]);
            Object.keys(lastCenters).forEach(k => delete lastCenters[k]);
            document.querySelectorAll('.crop-btn').forEach(b => b.classList.remove('is-modified'));
            // persist cleared adjustedState
            saveStateToStorage();
            // clear any badge warning state from previous image
            try { Object.keys(sizeBadges).forEach(k => { const b = sizeBadges[k]; if (b) { b.classList.remove('too-small-upscale'); b.classList.remove('too-small-no-upscale'); } }); } catch (er) {}
            ['downloadBtn', 'bulkBtn', 'dataBtn', 'resetViewBtn'].forEach(id => document.getElementById(id).disabled = false);
            // show the reset view button once an image has been loaded
            const rv = document.getElementById('resetViewBtn'); if (rv) rv.style.display = 'inline-block';
            // show export config controls
            const ec = document.getElementById('export-config'); if (ec) ec.style.display = 'flex';

            // store original file name info for exports
            try {
                currentOriginalFilename = file.name || '';
                // remove extension for basename
                const idx = currentOriginalFilename.lastIndexOf('.');
                currentOriginalBasename = idx > 0 ? currentOriginalFilename.substring(0, idx) : currentOriginalFilename;
            } catch (e) { currentOriginalFilename = currentOriginalBasename = ''; }

            initCropper();
        };
        reader.readAsDataURL(file);
    }

    function initCropper() {
        cropper = new Cropper(imgElement, {
            viewMode: 1,
            aspectRatio: (function(){ const r = presetConfig[currentId]?.ratio; return (typeof r === 'number' && isFinite(r)) ? r : NaN; })(),
            autoCropArea: 0.8,
            crop(event) {
                if (isSwitching) return;
                const d = cropper.getData(true);
                const min = presetConfig[currentId].minSize || 500;
                const isTooSmall = Math.min(d.width, d.height) < min;
                
                const display = document.getElementById('dim-display');
                display.className = isTooSmall ? 'warning' : '';
                
                // Displaying TL and BR coordinates (include preset minimum when too small)
                const minText = isTooSmall ? ` <b>(TOO SMALL â€” min ${min}px)</b>` : '';
                // if upscaling is allowed for this preset and crop is too small, warn user
                const preset = presetConfig[currentId] || {};
                const allowUpscale = preset.exportSize && !!preset.exportSize.allowUpscale;
                const scalingEnabled = exportScaleEnabled.hasOwnProperty(currentId) ? !!exportScaleEnabled[currentId] : ((preset.exportSize && preset.exportSize.width && preset.exportSize.height) ? true : false);
                const upscaleText = (isTooSmall && allowUpscale && scalingEnabled) ? ` <b style="color: #ff6666;">(Will upscale on export)</b>` : '';
                display.innerHTML = `Size: ${Math.round(d.width)}x${Math.round(d.height)}px | TL: ${Math.round(d.x)},${Math.round(d.y)} | BR: ${Math.round(d.x+d.width)},${Math.round(d.y+d.height)}${minText}${upscaleText}`;
                
                // compute new center
                const newCenter = { x: d.x + d.width/2, y: d.y + d.height/2 };

                // determine if this is the first adjustment for this preset
                const firstAdjust = !cropMemory[currentId];

                // store the data for this preset
                cropMemory[currentId] = { ...d };
                if (currentBtn) {
                    currentBtn.classList.add('is-modified');
                }

                // mark as adjusted (this distinguishes a reposition from default/cleared state)
                adjustedState[currentId] = true;
                saveStateToStorage();

                // If this preset had a previous center, apply delta to linked presets
                const prev = lastCenters[currentId];
                if (prev) {
                    const dx = newCenter.x - prev.x;
                    const dy = newCenter.y - prev.y;
                    if ((dx !== 0 || dy !== 0) && Object.values(linkedState).some(v => v)) {
                        applyCenterDeltaToLinked(dx, dy, currentId);
                    }
                }

                // update last center for this preset
                lastCenters[currentId] = newCenter;

                // toggle visual state on the cropper container so guide lines/borders can change color
                try {
                    const container = document.querySelector('.cropper-container');
                    if (container) container.classList.toggle('too-small', isTooSmall);
                } catch (e) { /* ignore */ }

                // If this preset allows upscaling for export and the crop is too small,
                // mark the size badge with the appropriate class depending on allowUpscale.
                try {
                    const badge = sizeBadges[currentId];
                    const preset = presetConfig[currentId] || {};
                    const allowUpscale = preset.exportSize && !!preset.exportSize.allowUpscale;
                    if (badge) {
                        badge.classList.toggle('too-small-upscale', isTooSmall && allowUpscale);
                        badge.classList.toggle('too-small-no-upscale', isTooSmall && !allowUpscale);
                    }
                    // Update dim-display to show size and upscale warning when reapplying stored crop
                    try {
                        const display = document.getElementById('dim-display');
                        if (display) {
                            const minText = isTooSmall ? ` <b>(TOO SMALL â€” min ${min}px)</b>` : '';
                            const scalingEnabled = exportScaleEnabled.hasOwnProperty(currentId) ? !!exportScaleEnabled[currentId] : ((preset.exportSize && preset.exportSize.width && preset.exportSize.height) ? true : false);
                            const upscaleText = (isTooSmall && allowUpscale && scalingEnabled) ? ` <b style="color: #ff6666;">(Will upscale on export)</b>` : '';
                            display.className = isTooSmall ? 'warning' : '';
                            display.innerHTML = `Size: ${Math.round(d.width)}x${Math.round(d.height)}px | TL: ${Math.round(d.x)},${Math.round(d.y)} | BR: ${Math.round(d.x+d.width)},${Math.round(d.y+d.height)}${minText}${upscaleText}`;
                        }
                    } catch (e) {}
                } catch (e) { /* ignore */ }

                // persist crop changes
                saveStateToStorage();
            },
            ready: updateUIOverlay
        });
    }

    function handlePresetChange(ratio, btn) {
        if (!cropper) return;
        isSwitching = true;
        document.querySelectorAll('.crop-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentBtn = btn;
        currentId = btn.getAttribute('data-id');
        const effectiveRatio = (typeof ratio === 'number' && isFinite(ratio)) ? ratio : NaN;
        cropper.setAspectRatio(effectiveRatio);
        if (cropMemory[currentId]) {
            cropper.setData(cropMemory[currentId]);
            // initialize last center for newly-selected preset
            const d = cropMemory[currentId];
            lastCenters[currentId] = { x: d.x + d.width/2, y: d.y + d.height/2 };
            // update size badge state for the selected preset (in case it was too-small)
            try {
                const min = presetConfig[currentId].minSize || 500;
                const isTooSmall = Math.min(d.width, d.height) < min;
                const badge = sizeBadges[currentId];
                const preset = presetConfig[currentId] || {};
                const allowUpscale = preset.exportSize && !!preset.exportSize.allowUpscale;
                if (badge) {
                    badge.classList.toggle('too-small-upscale', isTooSmall && allowUpscale);
                    badge.classList.toggle('too-small-no-upscale', isTooSmall && !allowUpscale);
                }
            } catch (e) {}
        }
        // clear any previous too-small highlight when switching presets
        try { const container = document.querySelector('.cropper-container'); if (container) container.classList.remove('too-small'); } catch(e){}

        updateUIOverlay();
        try { if (typeof window.updateExampleFilename === 'function') window.updateExampleFilename(); } catch(e){}
        setTimeout(() => { isSwitching = false; }, 150);
    }

    function updateUIOverlay() {
        const viewBox = document.querySelector('.cropper-view-box');
        if (!viewBox) return;
        viewBox.querySelectorAll('.ui-element-box').forEach(el => el.remove());
        if (!showOverlays) return;
        
        const overlays = presetConfig[currentId]?.overlays || [];
        overlays.forEach(o => {
            const div = document.createElement('div');
            div.className = 'ui-element-box';
            Object.assign(div.style, { 
                top: o.top + '%', 
                left: o.left + '%', 
                width: o.width + '%', 
                height: o.height + '%' 
            });
            viewBox.appendChild(div);
        });
    }

    // Toggle link state for a preset
    function toggleLink(id, linkBtn, parentBtn) {
        linkedState[id] = !linkedState[id];
        linkBtn.classList.toggle('active', linkedState[id]);
        parentBtn.classList.toggle('linked', linkedState[id]);

        // initialize last center if this preset already has crop data
        if (linkedState[id] && cropMemory[id]) {
            const d = cropMemory[id];
            lastCenters[id] = { x: d.x + d.width/2, y: d.y + d.height/2 };
        } else {
            delete lastCenters[id];
        }
        saveStateToStorage();
    }

    // Reset a preset's stored crop data and (if active) reset the cropper view
    function resetPresetCrop(id, resetBtn, parentBtn) {
        delete cropMemory[id];
        delete lastCenters[id];
        parentBtn.classList.remove('is-modified');

        // persist removal
        // clear adjusted state
        delete adjustedState[id];
        saveStateToStorage();

        // If the preset is currently selected, reset the cropper view to initial state
        if (id === currentId && cropper) {
            isSwitching = true;
            try {
                cropper.reset();
            } catch (e) {
                try { cropper.destroy(); } catch (err) {}
                initCropper();
            }
            const r = presetConfig[currentId]?.ratio;
            try { cropper.setAspectRatio((typeof r === 'number' && isFinite(r)) ? r : NaN); } catch (e) {}
            updateUIOverlay();
            try { const container = document.querySelector('.cropper-container'); if (container) container.classList.remove('too-small'); } catch(e){}
            setTimeout(() => { isSwitching = false; }, 120);
        } else {
            updateUIOverlay();
        }
        // clear any badge warning state for this preset
        try { const b = sizeBadges[id]; if (b) { b.classList.remove('too-small-upscale'); b.classList.remove('too-small-no-upscale'); } } catch (e) {}
    }

    // Reset image position & zoom (preserves crop data if present)
    function resetImageView() {
        if (!cropper) return;
        isSwitching = true;
        try {
            cropper.reset();
        } catch (e) {
            try { cropper.destroy(); } catch (err) {}
            initCropper();
        }

        // remove too-small visual state after resetting
        try { const container = document.querySelector('.cropper-container'); if (container) container.classList.remove('too-small'); } catch(e){}

        // if there's stored crop data for the current preset, reapply it
        if (cropMemory[currentId]) {
            try { cropper.setData(cropMemory[currentId]); } catch (e) {}
        }

        updateUIOverlay();
        setTimeout(() => { isSwitching = false; }, 120);
    }

    // Apply a center delta to all linked presets (does not change the active cropper view)
    function applyCenterDeltaToLinked(dx, dy, sourceId) {
        const imgW = imgElement.naturalWidth || imgElement.width || 1;
        const imgH = imgElement.naturalHeight || imgElement.height || 1;

        Object.keys(linkedState).forEach(id => {
            if (!linkedState[id] || id === sourceId) return;
            let d = cropMemory[id];
            if (!d) {
                // create a default based on source dimensions and target ratio
                const src = cropMemory[sourceId];
                if (!src) return;
                let w = src.width;
                let h = src.height;
                const r = presetConfig[id]?.ratio;
                if (typeof r === 'number' && isFinite(r) && r > 0) {
                    h = Math.round(w / r);
                }
                w = Math.min(w, imgW);
                h = Math.min(h, imgH);
                d = { width: w, height: h, x: Math.max(0, Math.min(src.x, imgW - w)), y: Math.max(0, Math.min(src.y, imgH - h)) };
            }

            const cx = d.x + d.width/2 + dx;
            const cy = d.y + d.height/2 + dy;
            let newX = cx - d.width/2;
            let newY = cy - d.height/2;
            newX = Math.max(0, Math.min(newX, imgW - d.width));
            newY = Math.max(0, Math.min(newY, imgH - d.height));

            cropMemory[id] = { ...d, x: newX, y: newY };
            const btn = document.querySelector(`.crop-btn[data-id="${id}"]`);
            if (btn) btn.classList.add('is-modified');
            lastCenters[id] = { x: newX + d.width/2, y: newY + d.height/2 };
            // linked move counts as an adjustment
            adjustedState[id] = true;
        });
        // persist linked crop changes all at once
        saveStateToStorage();
    }

    // Helper: Returns a Canvas based on stored crop data
    function getCroppedCanvas(data) {
        const canvas = document.createElement('canvas');
        canvas.width = data.width;
        canvas.height = data.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(imgElement, data.x, data.y, data.width, data.height, 0, 0, data.width, data.height);
        return canvas;
    }

    /**
     * Returns a canvas for the cropped data scaled to the preset's exportSize when available.
     * - If the preset has no exportSize, returns the original cropped canvas.
     * - Honors `allowUpscale` (if false, will not enlarge beyond the source crop size).
     */
    function getCroppedCanvasScaled(data, presetId) {
        const srcCanvas = getCroppedCanvas(data);
        try {
            // honor per-preset toggle: if user has disabled scaled export for this preset, return source canvas
            if (exportScaleEnabled.hasOwnProperty(presetId) && !exportScaleEnabled[presetId]) return srcCanvas;
            const preset = presetConfig[presetId] || {};
            const exp = preset.exportSize;
            if (!exp || !exp.width || !exp.height) return srcCanvas;

            let targetW = Number(exp.width) || srcCanvas.width;
            let targetH = Number(exp.height) || srcCanvas.height;

            // If upscaling is not allowed, clamp the target size down proportionally
            const allowUpscale = !!exp.allowUpscale;
            if (!allowUpscale) {
                const scale = Math.min(1, srcCanvas.width / targetW, srcCanvas.height / targetH);
                targetW = Math.max(1, Math.round(targetW * scale));
                targetH = Math.max(1, Math.round(targetH * scale));
            }

            // If target matches source, return source to avoid extra work
            if (targetW === srcCanvas.width && targetH === srcCanvas.height) return srcCanvas;
            // Progressive downscaling: repeatedly halve the canvas size until near target.
            // This often yields better quality and can be faster than a single large resample.
            const needsDownscale = srcCanvas.width > targetW || srcCanvas.height > targetH;

            if (needsDownscale) {
                let current = srcCanvas;
                // If the reduction is small, do a single high-quality draw.
                const reductionFactorW = current.width / targetW;
                const reductionFactorH = current.height / targetH;
                const maxReduction = Math.max(reductionFactorW, reductionFactorH);

                if (maxReduction <= 2) {
                    const out = document.createElement('canvas');
                    out.width = targetW; out.height = targetH;
                    const ctx = out.getContext('2d');
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(current, 0, 0, current.width, current.height, 0, 0, targetW, targetH);
                    return out;
                }

                // Otherwise perform multi-step halving until close to target size
                while ((current.width / 2) >= targetW || (current.height / 2) >= targetH) {
                    const tmp = document.createElement('canvas');
                    tmp.width = Math.max(1, Math.round(current.width / 2));
                    tmp.height = Math.max(1, Math.round(current.height / 2));
                    const tctx = tmp.getContext('2d');
                    tctx.imageSmoothingEnabled = true;
                    tctx.imageSmoothingQuality = 'high';
                    tctx.drawImage(current, 0, 0, current.width, current.height, 0, 0, tmp.width, tmp.height);
                    // prepare for next iteration
                    current = tmp;
                }

                // Final pass to exact target size
                const out = document.createElement('canvas');
                out.width = targetW; out.height = targetH;
                const octx = out.getContext('2d');
                octx.imageSmoothingEnabled = true;
                octx.imageSmoothingQuality = 'high';
                octx.drawImage(current, 0, 0, current.width, current.height, 0, 0, targetW, targetH);
                return out;
            } else {
                // Upscale (or equal) - single high-quality draw
                const out = document.createElement('canvas');
                out.width = targetW; out.height = targetH;
                const ctx = out.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(srcCanvas, 0, 0, srcCanvas.width, srcCanvas.height, 0, 0, targetW, targetH);
                return out;
            }
        } catch (e) {
            console.warn('getCroppedCanvasScaled failed, falling back to unscaled canvas', e);
            return srcCanvas;
        }
    }

    function performCrop() {
        if (!cropper || !cropMemory[currentId]) return;
        const filename = buildExportFilename(currentId);
        const canvas = getCroppedCanvasScaled(cropMemory[currentId], currentId);
        canvas.toBlob(blob => {
            saveAs(blob, filename);
        }, 'image/jpeg', 0.95);
    }

    function generateGallery() {
        try {
            const grid = document.getElementById('gallery-grid');
            if (!grid) throw new Error('Gallery grid element not found');
            grid.innerHTML = '';

            // Prefer adjustedState to determine which presets the user has modified
            const modifiedIds = Object.keys(adjustedState).filter(id => adjustedState[id]);

            if (!modifiedIds || modifiedIds.length === 0) {
                alert("Please adjust at least one crop first.");
                return;
            }

            let anyAdded = false;
            modifiedIds.forEach(id => {
                try {
                    const data = cropMemory[id];
                    if (!data) return; // skip entries without stored crop data
                    const canvas = getCroppedCanvasScaled(data, id);
                    const item = document.createElement('div');
                    item.className = 'gallery-item';
                    const filename = buildExportFilename(id);

                    item.innerHTML = `
                        <img src="${canvas.toDataURL('image/jpeg', 0.5)}">
                        <span style="display:block; margin-bottom:6px; font-weight:bold;">${presetConfig[id]?.title || id}</span>
                        <div style="font-family: monospace; font-size:0.85rem; color:#ddd; margin-bottom:8px; word-break:break-all;">${filename}</div>
                        <button class="action-btn download-btn" onclick="downloadSingleFromGallery('${id}')">Download JPG</button>
                    `;
                    grid.appendChild(item);
                    anyAdded = true;
                } catch (innerErr) {
                    console.warn('Skipping gallery item for', id, innerErr);
                }
            });

            if (!anyAdded) {
                alert('No valid adjusted crops available to preview.');
                return;
            }

            const overlay = document.getElementById('gallery-overlay');
            if (!overlay) throw new Error('Gallery overlay element not found');
            overlay.style.display = 'block';
        } catch (err) {
            console.error('generateGallery failed', err);
            alert('Failed to open gallery â€” see console for details.');
        }
    }

    window.downloadSingleFromGallery = (id) => {
        const filename = buildExportFilename(id);
        const canvas = getCroppedCanvasScaled(cropMemory[id], id);
        canvas.toBlob(blob => saveAs(blob, filename), 'image/jpeg', 0.95);
    };

    async function downloadAllAsZip() {
        const zip = new JSZip();
        const modifiedIds = Object.keys(cropMemory);

        for (const id of modifiedIds) {
            const canvas = getCroppedCanvasScaled(cropMemory[id], id);
            const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.95));
            const filename = buildExportFilename(id);
            zip.file(filename, blob);
        }
        
        const content = await zip.generateAsync({type:"blob"});
        // Build zip filename as <originalBase>_imageset_MMDDYYYY.zip
        const now = new Date();
        const mm = String(now.getMonth() + 1).padStart(2, '0');
        const dd = String(now.getDate()).padStart(2, '0');
        const yyyy = String(now.getFullYear());
        const dateToken = `${mm}${dd}${yyyy}`;
        const base = sanitizeToken(currentOriginalBasename) || 'image';
        const zipName = `${base}_imageset_${dateToken}.zip`;
        saveAs(content, zipName);
    }

    // Helper: sanitize token for filename components
    function sanitizeToken(s) {
        if (!s) return '';
        return String(s).trim().replace(/\s+/g, '-').replace(/[^A-Za-z0-9\-_]/g, '');
    }

    // Build export filename for a given preset id using selected Template, Country, Year, preset prefix, and original filename base
    function buildExportFilename(presetId) {
        const tpl = document.getElementById('templateSelect')?.value || '';
        const country = document.getElementById('countrySelect')?.value || '';
        const year = (new Date()).getFullYear();
        const presetPrefix = presetConfig[presetId]?.prefix || presetId;
        const parts = [];
        if (tpl) parts.push(sanitizeToken(tpl));
        if (country) parts.push(sanitizeToken(country));
        parts.push(String(year));
        parts.push(sanitizeToken(presetPrefix));
        const base = sanitizeToken(currentOriginalBasename) || 'image';
        parts.push(base);
        // join with underscore and ensure .jpg extension
        return parts.join('_') + '.jpg';
    }

    function showCoordinateOverlay() {
        const body = document.getElementById('data-table-body');
        // show rows only for presets that have crop data
        const rows = Object.entries(cropMemory).map(([id, d]) => `
            <tr>
                <td><b>${presetConfig[id]?.title || id}</b></td>
                <td>${Math.round(d.x)}, ${Math.round(d.y)}</td>
                <td>${Math.round(d.x + d.width)}, ${Math.round(d.y + d.height)}</td>
                <td>${Math.round(d.width)} x ${Math.round(d.height)}px</td>
            </tr>`).join('');
        if (!rows) {
            alert('No crop data available to show.');
            return;
        }
        body.innerHTML = rows;
        document.getElementById('data-overlay').style.display = 'block';
    }

    function toggleOverlays() {
        showOverlays = !showOverlays;
        document.getElementById('toggle-text').innerText = showOverlays ? "Hide UI Guides" : "Show UI Guides";
        updateUIOverlay();
    }

    function closeModal(id) { document.getElementById(id).style.display = 'none'; }

    // Drop Zone & Input Listeners
    document.getElementById('imageInput').addEventListener('change', (e) => processFile(e.target.files[0]));
    
    window.addEventListener('dragover', (e) => { 
        e.preventDefault(); 
        document.getElementById('drop-zone-overlay').style.display = 'flex'; 
    });
    
    document.getElementById('drop-zone-overlay').addEventListener('dragleave', () => {
        document.getElementById('drop-zone-overlay').style.display = 'none';
    });
    
    window.addEventListener('drop', (e) => { 
        e.preventDefault(); 
        document.getElementById('drop-zone-overlay').style.display = 'none'; 
        processFile(e.dataTransfer.files[0]); 
    });
</script>
</body>
</html>