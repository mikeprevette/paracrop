<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ParaCrop - Professional Batch Cropping</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <style>
        :root { --primary: #007bff; --success: #28a745; --dark: #1a1a1a; --border: #e0e0e0; --bulk: #9f156e77; --link: #42bc20c6; --zip: #fd7e14; --info: #17a2b8; --danger: #ff4444; }
        body { font-family: 'Inter', -apple-system, sans-serif; padding: 20px; background: #f4f7f9; color: #333; margin: 0; min-height: 100vh; }
        
        .container { max-width: 1200px; margin: 20px auto; background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); position: relative; z-index: 1; }
        
        header { 
            margin-bottom: 25px; padding-bottom: 15px; border-bottom: 1px solid var(--border); 
            display: flex; justify-content: space-between; align-items: center; gap: 20px;
        }

        .file-upload-wrapper { position: relative; display: inline-block; }
        #imageInput { position: absolute; left: 0; top: 0; opacity: 0; width: 100%; height: 100%; cursor: pointer; }
        .custom-file-btn {
            display: inline-flex; align-items: center; padding: 12px 24px;
            background: var(--primary); color: white; border-radius: 8px;
            font-weight: 600; cursor: pointer; transition: all 0.2s ease;
            box-shadow: 0 4px 6px rgba(0,123,255,0.2); border: 2px solid transparent;
        }
        .custom-file-btn:hover { background: #0056b3; transform: translateY(-1px); }

        .workspace { display: grid; grid-template-columns: 280px 1fr; gap: 30px; }
        .sidebar { display: flex; flex-direction: column; }
        .group-label { font-weight: 700; color: #999; margin: 15px 0 8px 0; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; }
        .crop-list { display: flex; flex-direction: column; gap: 8px; }
        .crop-btn { display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; cursor: pointer; border: 1px solid var(--border); border-radius: 8px; background: white; font-size: 0.9rem; transition: 0.12s; text-align: left; width: 100%; box-sizing: border-box; }
        .crop-btn.active { background: var(--primary); color: white; border-color: var(--primary); }

        .crop-btn .title { flex: 1; text-align: left; padding-right: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        .preset-controls { display: inline-flex; align-items: center; gap: 8px; }
        .reset-btn, .link-toggle { width: 30px; height: 30px; display: inline-flex; align-items: center; justify-content: center; font-size: 14px; border-radius: 6px; border: 1px solid #e6e6e6; background: #fff; color: #333; cursor: pointer; padding: 0; transition: all 0.12s ease; }
        .reset-btn:hover, .link-toggle:hover { background: #f6f7f8; transform: translateY(-1px); }
        .link-toggle.active { background: var(--link); color: #fff; border-color: rgba(0,0,0,0.06); box-shadow: 0 6px 18px rgba(111,66,193,0.12); }
        .crop-btn.linked { box-shadow: 0 0 0 2px rgba(111,66,193,0.06) inset; }

        .status-dot { width: 10px; height: 10px; border-radius: 50%; border: 1px solid #ddd; background: transparent; flex-shrink: 0; }
        .is-modified .status-dot { background: var(--success); border-color: var(--success); }
        .active .status-dot { border-color: white; background: white; }

        .editor-col { display: flex; flex-direction: column; align-items: flex-start; }
        .img-container { max-height: 70vh; width: 100%; background-color: var(--dark); border-radius: 8px; overflow: hidden; display: none; }
        img { display: block; max-width: 100%; }
        
        #dim-display { 
            margin-bottom: 15px; background: var(--dark); color: #00ff88; 
            padding: 12px 16px; border-radius: 6px; font-family: 'Courier New', monospace; 
            font-size: 0.8rem; line-height: 1.4; width: 100%; box-sizing: border-box; 
            border: 1px solid transparent; transition: all 0.2s;
        }

        #dim-display.warning {
            color: var(--danger);
            border-color: var(--danger);
            background: rgba(255, 68, 68, 0.1);
        }

        .ui-element-box { position: absolute; background: rgba(60, 60, 60, 0.7); border: 1px solid rgba(255, 255, 255, 0.3); pointer-events: none; z-index: 10; }
        .btn-stack { display: flex; flex-direction: column; gap: 10px; margin-top: 25px; }
        .action-btn { width: 100%; padding: 14px; border: none; border-radius: 8px; font-size: 0.95rem; font-weight: bold; cursor: pointer; transition: 0.2s; color: white; }
        .download-btn { background: var(--success); }
        .bulk-btn { background: var(--bulk); }
        .data-btn { background: var(--info); }
        .action-btn:disabled { background: #ccc; cursor: not-allowed; opacity: 0.6; }

        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(18, 18, 18, 0.98); z-index: 9999; overflow-y: auto; }
        .modal-content { max-width: 1100px; margin: 40px auto; padding: 0 20px; color: white; }
        .modal-header { position: sticky; top: 0; background: #121212; padding: 20px 0; display: flex; justify-content: space-between; align-items: center; z-index: 10; border-bottom: 1px solid #333; gap: 15px; }
        
        .data-table { width: 100%; border-collapse: collapse; margin-top: 30px; background: #222; border-radius: 8px; overflow: hidden; }
        .data-table th, .data-table td { text-align: left; padding: 15px; border-bottom: 1px solid #333; }
        .data-table th { background: #333; color: var(--info); text-transform: uppercase; font-size: 0.75rem; letter-spacing: 1px; }

        .gallery-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 30px; padding: 40px 0; }
        .gallery-item { background: #222; padding: 20px; border-radius: 12px; text-align: center; color: white; border: 1px solid #333; }
        .gallery-item img { max-width: 100%; height: auto; border-radius: 6px; margin-bottom: 15px; border: 1px solid #444; }
        
        #drop-zone-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 123, 255, 0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 10000; color: white; border: 8px dashed white; box-sizing: border-box; }
    </style>
</head>
<body id="body-drop">

<div id="drop-zone-overlay"><h2>Drop Image</h2></div>

<div class="container">
    <div id="gallery-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin:0; flex-grow: 1;">ParaCrop Export Review</h2>
                <button class="action-btn" style="background: var(--zip); width:auto; padding: 10px 20px;" onclick="downloadAllAsZip()">Download All as ZIP</button>
                <button class="action-btn" style="background: #444; width:auto; padding: 10px 20px;" onclick="closeModal('gallery-overlay')">Back to Editor</button>
            </div>
            <div id="gallery-grid" class="gallery-grid"></div>
        </div>
    </div>

    <div id="data-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Crop Coordinate Manifest</h2>
                <button class="action-btn" style="background: #444; width:auto; padding: 10px 20px;" onclick="closeModal('data-overlay')">Close</button>
            </div>
            <table class="data-table">
                <thead><tr><th>Preset Name</th><th>Top-Left (X, Y)</th><th>Bottom-Right (X, Y)</th><th>Final Size (WxH)</th></tr></thead>
                <tbody id="data-table-body"></tbody>
            </table>
        </div>
    </div>
    
    <header>
        <div class="file-upload-wrapper">
            <label for="imageInput" class="custom-file-btn">Choose or Drop Image</label>
            <input type="file" id="imageInput" accept="image/*">
        </div>
        <h2 style="margin:0;">ParaCrop</h2>
    </header>

    <div class="workspace">
        <div class="sidebar">
            <div id="dynamic-presets"></div>
            <div class="group-label">Tools</div>
            <button class="crop-btn" style="width:100%" onclick="toggleOverlays()"><span id="toggle-text">Hide UI Guides</span></button>

            <div class="btn-stack">
                <button class="action-btn download-btn" id="downloadBtn" onclick="performCrop()" disabled>Download Current</button>
                <button class="action-btn bulk-btn" id="bulkBtn" onclick="generateGallery()" disabled>Review All Adjusted</button>
                <button class="action-btn data-btn" id="dataBtn" onclick="showCoordinateOverlay()" disabled>View Crop Data Points</button>
            </div>
        </div>

        <div class="editor-col">
            <div id="dim-display">Waiting for image upload...</div>
            <div class="img-container" id="canvas-wrapper"><img id="image"></div>
        </div>
    </div>
</div>

<script>
    let presetConfig = {};

    // Load the presets from an external JSON file (presets.json)
    fetch('presets.json')
        .then(r => {
            if (!r.ok) throw new Error('Network response was not ok');
            return r.json();
        })
        .then(data => {
            presetConfig = data;
            // load persisted state first so UI reflects saved link/reset
            loadStateFromStorage();
            buildPresetsUI();

            // reflect persisted modified/linked state in the UI
            Object.keys(cropMemory).forEach(id => {
                const btn = document.querySelector(`.crop-btn[data-id="${id}"]`);
                if (btn) btn.classList.add('is-modified');
            });
            Object.keys(linkedState).forEach(id => {
                if (!linkedState[id]) return;
                const btn = document.querySelector(`.crop-btn[data-id="${id}"]`);
                const linkBtn = btn && btn.querySelector('.link-toggle');
                if (btn) btn.classList.add('linked');
                if (linkBtn) linkBtn.classList.add('active');
                if (cropMemory[id]) {
                    const d = cropMemory[id];
                    lastCenters[id] = { x: d.x + d.width/2, y: d.y + d.height/2 };
                }
            });
        })
        .catch(err => {
            console.error('Failed to load presets.json', err);
            alert('Failed to load presets.json â€” presets unavailable.');
        });

    let cropper, currentId = "default", currentBtn, cropMemory = {}, isSwitching = false, showOverlays = true;
    const imgElement = document.getElementById('image');

    // Link state for presets: when true the preset is part of the moving-center group
    const linkedState = {};
    const lastCenters = {};
    const adjustedState = {};

    // Persisted state keys
    const STORAGE_KEY = 'paracrop_state_v1';

    function saveStateToStorage() {
        try {
            const payload = { linkedState, cropMemory, adjustedState };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        } catch (e) {
            console.warn('Failed to save Paracrop state', e);
        }
    }

    function loadStateFromStorage() {
        try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return;
            const parsed = JSON.parse(raw);
            if (parsed.linkedState) Object.assign(linkedState, parsed.linkedState);
            if (parsed.cropMemory) Object.assign(cropMemory, parsed.cropMemory);
            if (parsed.adjustedState) Object.assign(adjustedState, parsed.adjustedState);
        } catch (e) {
            console.warn('Failed to load Paracrop state', e);
        }
    }

    // UI Initializer - renders presets and a link-toggle control per preset
    function buildPresetsUI() {
        const container = document.getElementById('dynamic-presets');
        container.innerHTML = '';
        const groups = {};
        
        Object.entries(presetConfig).forEach(([id, cfg]) => {
            if (!groups[cfg.group]) groups[cfg.group] = [];
            groups[cfg.group].push({ id, ...cfg });
        });

        Object.keys(groups).forEach(groupName => {
            const label = document.createElement('div');
            label.className = 'group-label';
            label.innerText = groupName;
            container.appendChild(label);

            const list = document.createElement('div');
            list.className = 'crop-list';
            
            groups[groupName].forEach(cfg => {
                const btn = document.createElement('button');
                btn.className = `crop-btn ${cfg.id === currentId ? 'active' : ''}`;
                btn.setAttribute('data-id', cfg.id);

                const leftSpan = document.createElement('span');
                leftSpan.className = 'title';
                leftSpan.innerText = cfg.title;

                const rightControls = document.createElement('span');
                rightControls.className = 'preset-controls';

                const resetBtn = document.createElement('button');
                resetBtn.type = 'button';
                resetBtn.className = 'reset-btn';
                resetBtn.title = 'Reset this preset crop';
                resetBtn.innerText = 'â†º';

                const linkBtn = document.createElement('button');
                linkBtn.type = 'button';
                linkBtn.className = 'link-toggle';
                linkBtn.title = 'Link center for group move';
                linkBtn.innerText = 'ðŸ”—';

                const statusDot = document.createElement('span');
                statusDot.className = 'status-dot';

                // Clicking the preset selects it
                btn.addEventListener('click', () => {
                    handlePresetChange(cfg.ratio, btn);
                });

                // Reset without selecting the preset
                resetBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    resetPresetCrop(cfg.id, resetBtn, btn);
                });

                // Toggle linking without selecting the preset
                linkBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleLink(cfg.id, linkBtn, btn);
                });

                rightControls.appendChild(resetBtn);
                rightControls.appendChild(linkBtn);
                rightControls.appendChild(statusDot);

                btn.appendChild(leftSpan);
                btn.appendChild(rightControls);

                // reflect persisted states
                if (linkedState[cfg.id]) {
                    linkBtn.classList.add('active');
                    btn.classList.add('linked');
                    if (cropMemory[cfg.id]) {
                        const d = cropMemory[cfg.id];
                        lastCenters[cfg.id] = { x: d.x + d.width/2, y: d.y + d.height/2 };
                    }
                }
                if (adjustedState[cfg.id]) {
                    btn.classList.add('is-modified');
                }

                list.appendChild(btn);
                if (cfg.id === currentId) currentBtn = btn;
            });
            container.appendChild(list);
        });
    }
    

    function processFile(file) {
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            imgElement.src = e.target.result;
            document.getElementById('canvas-wrapper').style.display = 'block';
            if (cropper) cropper.destroy();
            cropMemory = {};
            // clear adjusted flags and last centers so previous image adjustments do not carry over
            Object.keys(adjustedState).forEach(k => delete adjustedState[k]);
            Object.keys(lastCenters).forEach(k => delete lastCenters[k]);
            document.querySelectorAll('.crop-btn').forEach(b => b.classList.remove('is-modified'));
            // persist cleared adjustedState
            saveStateToStorage();
            ['downloadBtn', 'bulkBtn', 'dataBtn'].forEach(id => document.getElementById(id).disabled = false);
            initCropper();
        };
        reader.readAsDataURL(file);
    }

    function initCropper() {
        cropper = new Cropper(imgElement, {
            viewMode: 1,
            aspectRatio: (function(){ const r = presetConfig[currentId]?.ratio; return (typeof r === 'number' && isFinite(r)) ? r : NaN; })(),
            autoCropArea: 0.8,
            crop(event) {
                if (isSwitching) return;
                const d = cropper.getData(true);
                const min = presetConfig[currentId].minSize || 500;
                const isTooSmall = Math.min(d.width, d.height) < min;
                
                const display = document.getElementById('dim-display');
                display.className = isTooSmall ? 'warning' : '';
                
                // Displaying TL and BR coordinates
                display.innerHTML = `Size: ${d.width}x${d.height}px | TL: ${d.x},${d.y} | BR: ${d.x+d.width},${d.y+d.height} ${isTooSmall ? ' <b>(TOO SMALL)</b>' : ''}`;
                
                // compute new center
                const newCenter = { x: d.x + d.width/2, y: d.y + d.height/2 };

                // determine if this is the first adjustment for this preset
                const firstAdjust = !cropMemory[currentId];

                // store the data for this preset
                cropMemory[currentId] = { ...d };
                if (currentBtn) {
                    currentBtn.classList.add('is-modified');
                }

                // mark as adjusted (this distinguishes a reposition from default/cleared state)
                adjustedState[currentId] = true;
                saveStateToStorage();

                // If this preset had a previous center, apply delta to linked presets
                const prev = lastCenters[currentId];
                if (prev) {
                    const dx = newCenter.x - prev.x;
                    const dy = newCenter.y - prev.y;
                    if ((dx !== 0 || dy !== 0) && Object.values(linkedState).some(v => v)) {
                        applyCenterDeltaToLinked(dx, dy, currentId);
                    }
                }

                // update last center for this preset
                lastCenters[currentId] = newCenter;

                // persist crop changes
                saveStateToStorage();
            },
            ready: updateUIOverlay
        });
    }

    function handlePresetChange(ratio, btn) {
        if (!cropper) return;
        isSwitching = true;
        document.querySelectorAll('.crop-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentBtn = btn;
        currentId = btn.getAttribute('data-id');
        const effectiveRatio = (typeof ratio === 'number' && isFinite(ratio)) ? ratio : NaN;
        cropper.setAspectRatio(effectiveRatio);
        if (cropMemory[currentId]) {
            cropper.setData(cropMemory[currentId]);
            // initialize last center for newly-selected preset
            const d = cropMemory[currentId];
            lastCenters[currentId] = { x: d.x + d.width/2, y: d.y + d.height/2 };
        }
        
        updateUIOverlay();
        setTimeout(() => { isSwitching = false; }, 150);
    }

    function updateUIOverlay() {
        const viewBox = document.querySelector('.cropper-view-box');
        if (!viewBox) return;
        viewBox.querySelectorAll('.ui-element-box').forEach(el => el.remove());
        if (!showOverlays) return;
        
        const overlays = presetConfig[currentId]?.overlays || [];
        overlays.forEach(o => {
            const div = document.createElement('div');
            div.className = 'ui-element-box';
            Object.assign(div.style, { 
                top: o.top + '%', 
                left: o.left + '%', 
                width: o.width + '%', 
                height: o.height + '%' 
            });
            viewBox.appendChild(div);
        });
    }

    // Toggle link state for a preset
    function toggleLink(id, linkBtn, parentBtn) {
        linkedState[id] = !linkedState[id];
        linkBtn.classList.toggle('active', linkedState[id]);
        parentBtn.classList.toggle('linked', linkedState[id]);

        // initialize last center if this preset already has crop data
        if (linkedState[id] && cropMemory[id]) {
            const d = cropMemory[id];
            lastCenters[id] = { x: d.x + d.width/2, y: d.y + d.height/2 };
        } else {
            delete lastCenters[id];
        }
        saveStateToStorage();
    }

    // Reset a preset's stored crop data and (if active) reset the cropper view
    function resetPresetCrop(id, resetBtn, parentBtn) {
        delete cropMemory[id];
        delete lastCenters[id];
        parentBtn.classList.remove('is-modified');

        // persist removal
        // clear adjusted state
        delete adjustedState[id];
        saveStateToStorage();

        // If the preset is currently selected, reset the cropper view to initial state
        if (id === currentId && cropper) {
            isSwitching = true;
            try {
                cropper.reset();
            } catch (e) {
                try { cropper.destroy(); } catch (err) {}
                initCropper();
            }
            const r = presetConfig[currentId]?.ratio;
            try { cropper.setAspectRatio((typeof r === 'number' && isFinite(r)) ? r : NaN); } catch (e) {}
            updateUIOverlay();
            setTimeout(() => { isSwitching = false; }, 120);
        } else {
            updateUIOverlay();
        }
    }

    // Apply a center delta to all linked presets (does not change the active cropper view)
    function applyCenterDeltaToLinked(dx, dy, sourceId) {
        const imgW = imgElement.naturalWidth || imgElement.width || 1;
        const imgH = imgElement.naturalHeight || imgElement.height || 1;

        Object.keys(linkedState).forEach(id => {
            if (!linkedState[id] || id === sourceId) return;
            let d = cropMemory[id];
            if (!d) {
                // create a default based on source dimensions and target ratio
                const src = cropMemory[sourceId];
                if (!src) return;
                let w = src.width;
                let h = src.height;
                const r = presetConfig[id]?.ratio;
                if (typeof r === 'number' && isFinite(r) && r > 0) {
                    h = Math.round(w / r);
                }
                w = Math.min(w, imgW);
                h = Math.min(h, imgH);
                d = { width: w, height: h, x: Math.max(0, Math.min(src.x, imgW - w)), y: Math.max(0, Math.min(src.y, imgH - h)) };
            }

            const cx = d.x + d.width/2 + dx;
            const cy = d.y + d.height/2 + dy;
            let newX = cx - d.width/2;
            let newY = cy - d.height/2;
            newX = Math.max(0, Math.min(newX, imgW - d.width));
            newY = Math.max(0, Math.min(newY, imgH - d.height));

            cropMemory[id] = { ...d, x: newX, y: newY };
            const btn = document.querySelector(`.crop-btn[data-id="${id}"]`);
            if (btn) btn.classList.add('is-modified');
            lastCenters[id] = { x: newX + d.width/2, y: newY + d.height/2 };
            // linked move counts as an adjustment
            adjustedState[id] = true;
        });
        // persist linked crop changes all at once
        saveStateToStorage();
    }

    // Helper: Returns a Canvas based on stored crop data
    function getCroppedCanvas(data) {
        const canvas = document.createElement('canvas');
        canvas.width = data.width;
        canvas.height = data.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(imgElement, data.x, data.y, data.width, data.height, 0, 0, data.width, data.height);
        return canvas;
    }

    function performCrop() {
        if (!cropper || !cropMemory[currentId]) return;
        const prefix = presetConfig[currentId].prefix || currentId;
        const canvas = getCroppedCanvas(cropMemory[currentId]);
        canvas.toBlob(blob => {
            saveAs(blob, `${prefix}.jpg`);
        }, 'image/jpeg', 0.95);
    }

    function generateGallery() {
        const grid = document.getElementById('gallery-grid');
        grid.innerHTML = '';
        const modifiedIds = Object.keys(cropMemory);
        
        if (modifiedIds.length === 0) {
            alert("Please adjust at least one crop first.");
            return;
        }
        
        modifiedIds.forEach(id => {
            const data = cropMemory[id];
            const canvas = getCroppedCanvas(data);
            const item = document.createElement('div');
            item.className = 'gallery-item';
            
            item.innerHTML = `
                <img src="${canvas.toDataURL('image/jpeg', 0.5)}">
                <span style="display:block; margin-bottom:10px; font-weight:bold;">${presetConfig[id].title}</span>
                <button class="action-btn download-btn" onclick="downloadSingleFromGallery('${id}')">Download JPG</button>
            `;
            grid.appendChild(item);
        });
        document.getElementById('gallery-overlay').style.display = 'block';
    }

    window.downloadSingleFromGallery = (id) => {
        const prefix = presetConfig[id].prefix || id;
        const canvas = getCroppedCanvas(cropMemory[id]);
        canvas.toBlob(blob => saveAs(blob, `${prefix}.jpg`), 'image/jpeg', 0.95);
    };

    async function downloadAllAsZip() {
        const zip = new JSZip();
        const modifiedIds = Object.keys(cropMemory);
        
        for (const id of modifiedIds) {
            const canvas = getCroppedCanvas(cropMemory[id]);
            const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.95));
            zip.file(`${presetConfig[id].prefix || id}.jpg`, blob);
        }
        
        const content = await zip.generateAsync({type:"blob"});
        saveAs(content, "ParaCrop-Batch.zip");
    }

    function showCoordinateOverlay() {
        const body = document.getElementById('data-table-body');
        body.innerHTML = Object.entries(cropMemory).map(([id, d]) => `
            <tr>
                <td><b>${presetConfig[id].title}</b></td>
                <td>${Math.round(d.x)}, ${Math.round(d.y)}</td>
                <td>${Math.round(d.x + d.width)}, ${Math.round(d.y + d.height)}</td>
                <td>${Math.round(d.width)} x ${Math.round(d.height)}px</td>
            </tr>`).join('');
        document.getElementById('data-overlay').style.display = 'block';
    }

    function toggleOverlays() {
        showOverlays = !showOverlays;
        document.getElementById('toggle-text').innerText = showOverlays ? "Hide UI Guides" : "Show UI Guides";
        updateUIOverlay();
    }

    function closeModal(id) { document.getElementById(id).style.display = 'none'; }

    // Drop Zone & Input Listeners
    document.getElementById('imageInput').addEventListener('change', (e) => processFile(e.target.files[0]));
    
    window.addEventListener('dragover', (e) => { 
        e.preventDefault(); 
        document.getElementById('drop-zone-overlay').style.display = 'flex'; 
    });
    
    document.getElementById('drop-zone-overlay').addEventListener('dragleave', () => {
        document.getElementById('drop-zone-overlay').style.display = 'none';
    });
    
    window.addEventListener('drop', (e) => { 
        e.preventDefault(); 
        document.getElementById('drop-zone-overlay').style.display = 'none'; 
        processFile(e.dataTransfer.files[0]); 
    });
</script>
</body>
</html>